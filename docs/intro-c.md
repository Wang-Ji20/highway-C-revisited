C 语言记事本

- C 传递参数的模型： call by value
- 字符串连接 "a" "b" 会自动拼接为 "ab"，换行的时候有用。
- 数组初始化的 trick

```c
a[10] = {[0 ... 3] = 1}; // 自动展开
b[10] = {[1] 4, [5] 5}; // 指定初始化
```

- 自动变量、静态变量、寄存器变量、易变变量
  - auto 不是 C++ 的 auto，指的是依照作用域规则自动分配和释放。
  - 静态变量两个功能：内部链接、生命周期
  - 寄存器变量不能取地址，通常不需要
  - volatile 避免一些优化，确保从内存中的读取，在写信号处理函数的时候有用。
- 外部变量 -- 函数本身是外部的，变量默认引用内部的，使用外部变量需要 extern，static 可以让别的文件不能使用自己的变量。可以在函数内声明函数，但不能定义。
- 变量遮蔽 -- 子作用域同名变量会覆盖。
- 下面的宏是唯一可行的复合语句块。{} 语句块会在 if else 的时候出问题。
  ```c
  #define aaa(x) do {} while(0);
  ```
- 替代 define 的若干方法：

```c
static const a;
enum {a=4};
inline int f() {}
```

---

- 一元运算符的优先级比算术运算符的优先级高，所以 y = *ip + 1 是 *ip 指向的对象 + 1
- 一元运算符是从右到左结合的，所以 *ip++ ===  *(ip++)
- 指针和数组虽然紧密结合，但二者很不一样。比如，不能对数组做算术运算。
- 指针类型对于指针的算术运算非常重要。一个 int 类型的指针每次 +1 的时候实际上 +4。
  指针的算术运算 减法是合法的。两个指针相加不合法。

  ```c
  char amessage[] = "aaa";
  char *pmessage = "aaa";
  ```

  不同，前者可以修改其内容，后者指向的是一个字符串常量，修改行为未定义( 大概会把字符串放在 read-only 区域 )。
- 进栈和出栈的写法

  ```
  *p++ = val;
  val = *--p;
  ```

---

- 结构可以拷贝、**赋值**、传递给函数、**被函数返回， 但是不可以比较。判等也不行**
- 有一点我们需要注意，gets 函数在读取字符串时将删除结尾的换行符('\n'), 而 puts 函数在写入字符串时将在结尾添加一个换行符。
